{"version":3,"file":"index.umd.min.js","sources":["../src/array/arrChunks/arrChunks.ts","../src/array/arrCross/arrCross.ts","../src/array/arrDiff/arrDiff.ts","../src/array/arrEject/arrEject.ts","../src/array/arrProd/arrProd.ts","../src/array/arrSum/arrSum.ts","../src/array/arrUnion/arrUnion.ts","../src/math/vecDot/vecDot.ts","../src/math/vecMag/vecMag.ts","../src/number/numAbbr/numAbbr.ts","../src/number/numOrd/numOrd.ts","../src/number/parseNum/parseNum.ts","../src/object/hasKey/hasKey.ts","../src/object/objEqual/objEqual.ts","../src/object/objDiff/objDiff.ts","../src/object/objFlush/objFlush.ts","../src/object/objPick/objPick.ts","../src/string/snakeCase/snakeCase.ts","../src/string/strCap/strCap.ts","../src/string/strTunc/strTrunc.ts","../src/url/paramsToObj/paramsToObj.ts","../src/math/clamp/clamp.ts"],"sourcesContent":["/**\n * Splits a parent array into smaller chunks\n *\n * @example\n * arrChunks([1, 2, 3, 4], 2);\n * => [[1, 2], [3, 4]]\n *\n * @param a - An array\n * @param size - Individual chunk size\n */\nexport const arrChunks = <Type extends unknown[]>(\n  a: Type,\n  size: number,\n): Type[] => {\n  const chunks: Type[] = [];\n\n  for (let i = 0; i < a.length; i += size) {\n    chunks.push(a.slice(i, i + size) as Type);\n  }\n\n  return chunks;\n};\n\nexport { arrChunks as arrayToChunks, arrChunks as arrayChunks };\n","/**\n * Returns the common elements from two arrays\n *\n * @example\n * arrCross([1, 2, 3, 4], [2, 3]);\n * => [2, 3]\n *\n * @param a - First array\n * @param b - Second array\n */\nexport const arrCross = <Type extends unknown[]>(\n  a: unknown[],\n  b: unknown[],\n): Type => a.filter((element) => b.indexOf(element) !== -1) as Type;\n\nexport { arrCross as arrayCross, arrCross as arrayIntersect };\n","/**\n * Returns elements from the first array that are not present in the second array\n *\n * @example\n * arrDiff([1, 2, 3, 4], [2, 3]);\n * => [1, 4]\n *\n * @param a - First array\n * @param b - Second array\n */\nexport const arrDiff = <Type extends unknown[]>(\n  a: unknown[],\n  b: unknown[],\n): Type => a.filter((element) => b.indexOf(element) === -1) as Type;\n\nexport {\n  arrDiff as arrayDiff,\n  // Users might actually confuse arrDiff with array diffing\n  arrDiff as arrayDifference,\n};\n","type ArrayElement<ArrayType extends unknown[]> = ArrayType[number];\n\nconst ejectElement = (element: unknown, array: unknown[]): void => {\n  const index = array.indexOf(element);\n\n  if (index > -1) {\n    array.splice(index, 1);\n  }\n};\n\n/**\n * Removes one or more elements from an array\n *\n * @example\n * arrEject([1, 2, 3, 4], 2);\n * => [1, 3, 4]\n *\n * @param a - An array\n * @param elements - A single element or an array of elements to eject\n * @param mutate - Whether to mutate the original array\n */\nexport const arrEject = <Type extends unknown[]>(\n  a: unknown[],\n  elements: ArrayElement<Type> | ArrayElement<Type>[],\n  mutate = true,\n): Type => {\n  const operand = mutate ? a : [...a];\n\n  if (Array.isArray(elements)) {\n    for (const element of elements) {\n      ejectElement(element, operand);\n    }\n  } else {\n    ejectElement(elements, operand);\n  }\n\n  return operand as Type;\n};\n\nexport { arrEject as arrayEject, arrEject as arrayDelete };\n","/**\n * Returns the product of elements of an array\n *\n * @example\n * arrProd([2, 4, 8]);\n * => 64\n *\n * @param a - A numeric array\n */\nexport const arrProd = (a: number[]): number =>\n  a.reduce((previousValue, currentValue) => previousValue * currentValue, 1);\n\nexport { arrProd as arrayProd, arrProd as arrayProduct };\n","/**\n * Returns the sum of elements of an array\n *\n * @example\n * arrSum([1, 2, 3]);\n * => 6\n *\n * @param a - A numeric array\n */\nexport const arrSum = (a: number[]): number =>\n  a.reduce((previousValue, currentValue) => previousValue + currentValue, 0);\n\nexport { arrSum as arraySum };\n","/**\n * Returns a unique union of elements of two arrays\n *\n * @example\n * arrUnion([1, 2, 3, 4, 5], [1, 3, 5, 7]);\n * => [1, 2, 3, 4, 5, 7]\n *\n * @param a - First array\n * @param b - Second array\n */\nexport const arrUnion = <Type extends unknown[]>(\n  a: unknown[],\n  b: unknown[],\n): Type => [...new Set([...a, ...b])] as Type;\n\nexport { arrUnion as arrayUnion, arrUnion as arrayMerge };\n","import type { Vector } from '../types';\n\n/**\n * Returns the dot product of two vectors\n *\n * @example\n * vecDot([1, 2], [3, 4]);\n * => 11\n *\n * @param a - First vector\n * @param b - Second vector\n */\nexport const vecDot = (a: Vector, b: Vector): number =>\n  a\n    .map((_, index) => (a[index] || 0) * (b[index] || 0))\n    .reduce((previousValue, currentValue) => previousValue + currentValue);\n\nexport { vecDot as vectorDot };\n","import type { Vector } from '../types';\nimport { vecDot } from '../vecDot';\n\n/**\n * Returns the magnitude of a vector\n *\n * @example\n * vecMag([3, 4]);\n * => 5\n *\n * @param a - A vector\n */\nexport const vecMag = (a: Vector): number => Math.sqrt(vecDot(a, a));\n\nexport { vecMag as vectorMag };\n","export const defaultAbbreviations = ['', 'k', 'M', 'B', 'T', 'P', 'E'] as const;\n\n/**\n * Abbreviates a number\n *\n * @example\n * numAbbr(1e3);\n * => \"1k\"\n *\n * @param a - A number\n * @param suppliedAbbreviations - Optional custom abbreviations\n */\nexport const numAbbr = (\n  a: number,\n  suppliedAbbreviations?: string[],\n): string => {\n  const abbreviations = suppliedAbbreviations || defaultAbbreviations;\n  const positive = Math.sign(a) >= 0;\n\n  a = Math.abs(a);\n\n  const level = (Math.log10(a) / 3) | 0;\n\n  if (level == 0) {\n    return `${!positive ? '-' : ''}${a}`;\n  }\n\n  const abbreviation = abbreviations[level];\n\n  if (!abbreviation) {\n    throw new RangeError('Number out of range');\n  }\n\n  const result = String(Number((a / Math.pow(10, level * 3)).toFixed(1)));\n\n  return `${!positive ? '-' : ''}${result}${abbreviation}`;\n};\n\nexport { numAbbr as numAbbreviate, numAbbr as numberAbbreviate };\n","export const defaultOrdinals = ['th', 'st', 'nd', 'rd'] as const;\n\n/**\n * Suffixes an ordinal to a number\n *\n * @example\n * numOrd(10);\n * => \"10th\"\n *\n * @param a - A number\n * @param suppliedOrdinals - Optional custom ordinals\n * @see https://gist.github.com/jlbruno/1535691/db35b4f3af3dcbb42babc01541410f291a8e8fac\n */\nexport const numOrd = (a: number, suppliedOrdinals?: string[]): string => {\n  const ordinals = suppliedOrdinals || defaultOrdinals;\n  const index = a % 100;\n\n  return (\n    a + (ordinals[(index - 20) % 10] || ordinals[index] || ordinals[0] || '')\n  );\n};\n\nexport { numOrd as numOrdinal, numOrd as numberOrd, numOrd as numberOrdinal };\n","/**\n * Converts a string to an integer or a floating value\n *\n * @example\n * parseNum('64');\n * => 64\n *\n * parseNum('2.14');\n * => 2.14\n *\n * @param value - The string to parse\n * @param returnNull - Whether to return null if the input cannot be parsed to a number\n */\nexport const parseNum = <ReturnType extends boolean = false>(\n  value: string | number,\n  returnNull?: ReturnType,\n): ReturnType extends false ? string | number : number | null =>\n  Number.isNaN(Number(value)) || Number.isNaN(Number.parseInt('' + value))\n    ? returnNull\n      ? null\n      : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (value as any)\n    : +('' + value);\n\nexport { parseNum as parseNumber, parseNum as toNumber };\n","/**\n * Checks if a key or an array of keys exists on an object\n *\n * @example\n * const obj = {\n *   \"foo\": true,\n *   \"bar\": false\n * };\n *\n * hasKey(obj, 'foo');\n * => true\n *\n * hasKey(obj, ['foo', 'bar']);\n * => true\n *\n * @param a - An object\n * @param keys - The keys to check\n */\nexport const hasKey = <\n  Type extends Record<string | number | symbol, unknown>,\n  Key extends keyof Type,\n>(\n  a: Type,\n  keys: Key | Key[],\n): boolean => {\n  let hasKeys = true;\n\n  if (Array.isArray(keys)) {\n    let i = keys.length;\n\n    while (i--) {\n      if (!hasKey(a, keys[i] as Key)) {\n        hasKeys = false;\n        break;\n      }\n    }\n  } else {\n    if (!Object.prototype.hasOwnProperty.call(a, keys)) {\n      hasKeys = false;\n    }\n  }\n\n  return hasKeys;\n};\n\nexport { hasKey as objHasKey, hasKey as objectHasKey };\n","// TODO: Implement deep comparison\n\n/**\n * Compares two objects for equality\n *\n * @example\n * objEqual({ foo: 1, bar: 2 }, { foo: 1, bar: 2 });\n * => true\n *\n * objEqual({ foo: 1, bar: 2 }, { foo: 1, bar: false });\n * => false\n *\n * @param a - First object\n * @param b - Second object\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const objEqual = <Type extends Record<string | number | symbol, any>>(\n  a: Type,\n  b: Type,\n): boolean => {\n  if (typeof a == 'object' && a != null && typeof b == 'object' && b != null) {\n    if (Object.keys(a).length - Object.keys(b).length !== 0) {\n      return false;\n    }\n\n    for (const objKey in a) {\n      if (!(objKey in b) || !objEqual(a[objKey], b[objKey])) {\n        return false;\n      }\n    }\n\n    for (const relObjKey in b) {\n      if (!(relObjKey in a) || !objEqual(b[relObjKey], a[relObjKey])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return a === b;\n  }\n};\n\nexport { objEqual as objectEqual };\n","import { hasKey } from '../hasKey';\nimport { objEqual } from '../objEqual';\n\n/**\n * Returns an array of identical keys with different values across two objects\n *\n * @example\n * objDiff({ foo: 1, bar: 2 }, { foo: true, bar: 2 });\n * => ['foo']\n *\n * objDiff({ foo: 1, bar: 2 }, { foo: 1, bar: 2 });\n * => false\n *\n * @param a - First object\n * @param b - Second object\n */\nexport const objDiff = <\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Type extends Record<string | number | symbol, any>,\n  Key extends keyof Type,\n>(\n  a: Type,\n  b: Type,\n): Key[] | false => {\n  if (objEqual(a, b)) {\n    return false;\n  }\n\n  const modifiedKeys: Key[] = [];\n  const keys = Object.keys(a);\n  let i = keys.length;\n\n  while (i--) {\n    if (\n      hasKey(b, keys[i] as Key) &&\n      !objEqual(a[keys[i] as Key], b[keys[i] as Key])\n    ) {\n      modifiedKeys.push(keys[i] as Key);\n    }\n  }\n\n  return modifiedKeys.length ? modifiedKeys : false;\n};\n\nexport {\n  objDiff as objDifference,\n  objDiff as objectDiff,\n  // Users might actually confuse objDiff with object diffing\n  objDiff as objectDifference,\n};\n","import { hasKey } from '../hasKey';\n\n/**\n * Deletes a single key or multiple keys from an object\n *\n * @example\n * const obj = {\n *   \"foo\": true,\n *   \"bar\": false,\n *   \"one\": 2\n * };\n *\n * objFlush(obj, 'foo');\n * =>\n * {\n *   \"bar\": false,\n *   \"one\": 2\n * }\n *\n * objFlush(obj, ['foo', 'bar']);\n * => {\n *   \"one\": 2\n * }\n *\n * objFlush(obj);\n * => {}\n *\n * @param a - An object\n * @param keys - The key or an array of keys to remove.\n */\nexport const objFlush = <\n  Type extends Record<string | number | symbol, unknown>,\n  Key extends keyof Type,\n>(\n  a: Type,\n  keys?: Key | Key[],\n): Partial<Type> => {\n  if (!keys) {\n    for (const key in a) {\n      if (hasKey(a, key)) {\n        delete a[key];\n      }\n    }\n  } else if (Array.isArray(keys)) {\n    let i = keys.length;\n\n    while (i--) {\n      if (hasKey(a, keys[i] as Key)) {\n        delete a[keys[i] as Key];\n      }\n    }\n  } else if (hasKey(a, keys)) {\n    delete a[keys];\n  }\n\n  return a;\n};\n\nexport { objFlush as objectFlush };\n","import { hasKey } from '../hasKey';\n\n/**\n * Returns a new object with the specified keys from a source object\n *\n * @example\n * const obj = {\n *   \"one\": true,\n *   \"two\": false,\n *   \"foo\": \"bar\"\n * };\n *\n * const newObj = objPick(obj, ['two', 'foo']);\n * =>\n * {\n *   \"two\": false,\n *   \"foo\": \"bar\"\n * }\n *\n * @param a - An object\n * @param keys - An array of keys to pick\n * @param options - Optional options\n * @param options.upsert - Whether to create new properties for missing keys\n * @param options.defaultValue - Default value to use when upsert-ing\n */\nexport const objPick = <\n  Type extends Record<string | number | symbol, unknown>,\n  Key extends keyof Type,\n>(\n  a: Type,\n  keys: Key[] | string[],\n  options?: {\n    defaultValue?: unknown;\n    upsert?: boolean;\n  },\n): Record<(typeof keys)[number], (typeof a)[keyof typeof a]> => {\n  const { defaultValue, upsert } = options || {};\n  const newObj: Record<string | number | symbol, unknown> = {};\n  let i = keys.length;\n\n  while (i--) {\n    if (hasKey(a, keys[i] as Key)) {\n      newObj[keys[i] as Key] = a[keys[i] as Key];\n    } else if (upsert) {\n      newObj[keys[i] as Key] = defaultValue || null;\n    }\n  }\n\n  return newObj as Record<(typeof keys)[number], (typeof a)[keyof typeof a]>;\n};\n\nexport { objPick as objectPick };\n","/**\n * Converts a string to snake_case\n *\n * @example\n * snakeCase(\"camelCase\");\n * => \"camel_case\"\n *\n * @param a - A string\n * @param separator - An optional separator to use instead of underscore\n */\nexport const snakeCase = (a: string, separator?: string): string => {\n  const matches = a.match(\n    /[A-Z]{2,}(?=[A-Z][a-z]+\\d*|\\b)|[A-Z]?[a-z]+\\d*|[A-Z]|\\d+/g,\n  );\n\n  return matches\n    ? matches.map((chunk) => chunk.toLowerCase()).join(separator || '_')\n    : a;\n};\n\nexport { snakeCase as toSnakeCase };\n","/**\n * Capitalizes the first letter of a phrase\n *\n * @example\n * strCap(\"lower case\");\n * => \"Lower case\"\n *\n * @param a - A string\n */\nexport const strCap = (a: string): string =>\n  a.charAt(0).toUpperCase() + a.slice(1);\n\nexport {\n  strCap as strCapitalize,\n  strCap as stringCap,\n  strCap as stringCapitalize,\n};\n","/**\n * Truncates a long string\n *\n * @example\n * strTrunc(\"A very long string\", 5);\n * => \"A very...\"\n *\n * @param a - A long string\n * @param limit - Limit of characters\n * @param delimiter - Optional delimiter (terminating suffix)\n */\nexport const strTrunc = (a: string, limit: number, delimiter = '...'): string =>\n  a.length > limit ? `${a.substring(0, limit + 1)}${delimiter}` : a;\n\nexport {\n  strTrunc as strTruncate,\n  strTrunc as stringTrunc,\n  strTrunc as stringTruncate,\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { URLSearchParams } from 'url';\nimport { parseNum } from '../../number';\n\n/**\n * Converts url parameters to object\n *\n * @example\n * paramsToObj(new URLSearchParams(\"?foo=bar&bar=doe&foo=5&john=null\"));\n * => {\n *   foo: [\"bar\", \"5\"],\n *   bar: \"doe\",\n *   john: \"null\"\n * }\n *\n * paramsToObj(\n *   new URLSearchParams('?foo=5&bar=null', {\n *     parseNulls: true,\n *     parseNumbers: true,\n *   }),\n * );\n * => {\n *   foo: 5,\n *   bar: null\n * }\n *\n * @param params - Search params\n * @param options - Optional options\n * @param options.parseNumbers - Whether to parse numeric string parameter values\n * @param options.parseNulls - Whether to parse null string parameter values\n */\nexport const paramsToObj = <Type = any>(\n  params: URLSearchParams,\n  options?: {\n    parseNulls?: boolean;\n    parseNumbers?: boolean;\n  },\n): Type => {\n  const iterator = params.entries();\n  const object: any = {};\n\n  for (let itr = iterator.next(); !itr.done; itr = iterator.next()) {\n    const [key, rawValue] = itr.value;\n    const value =\n      options?.parseNulls && rawValue === 'null'\n        ? null\n        : options?.parseNumbers\n        ? parseNum(rawValue)\n        : rawValue;\n\n    if (object[key]) {\n      if (Array.isArray(object[key])) {\n        object[key].push(value);\n      } else {\n        object[key] = [object[key], value];\n      }\n    } else {\n      object[key] = value;\n    }\n  }\n\n  return object as Type;\n};\n\nexport { paramsToObj as paramsToObject };\n","/**\n * Clamps a number to bounds\n *\n * @example\n * clamp(0, 64, 32);\n * => 32\n *\n * @param min - The lower bound\n * @param value - Un-clamped value\n * @param max - The upper bound\n */\nexport const clamp = (min: number, value: number, max: number): number =>\n  Math.min(Math.max(value, min), max);\n"],"names":["arrChunks","a","size","chunks","i","length","push","slice","arrCross","b","filter","element","indexOf","arrDiff","ejectElement","array","index","splice","arrEject","elements","mutate","operand","__spreadArray","__read","Array","isArray","elements_1","__values","elements_1_1","done","next","value","arrProd","reduce","previousValue","currentValue","arrSum","arrUnion","Set","vecDot","map","_","vecMag","Math","sqrt","defaultAbbreviations","numAbbr","suppliedAbbreviations","abbreviations","positive","sign","abs","level","log10","concat","abbreviation","RangeError","result","String","Number","pow","toFixed","defaultOrdinals","numOrd","suppliedOrdinals","ordinals","parseNum","returnNull","isNaN","parseInt","hasKey","keys","hasKeys","Object","prototype","hasOwnProperty","call","objEqual","objKey","relObjKey","objDiff","modifiedKeys","objFlush","key","objPick","options","_a","defaultValue","upsert","newObj","snakeCase","separator","matches","match","chunk","toLowerCase","join","strCap","charAt","toUpperCase","strTrunc","limit","delimiter","substring","paramsToObj","params","iterator","entries","object","itr","rawValue","parseNulls","parseNumbers","min","max"],"mappings":"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"}