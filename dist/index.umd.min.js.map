{"version":3,"file":"index.umd.min.js","sources":["../src/object/objPick/objPick.ts","../src/object/hasKey/hasKey.ts","../src/object/objSanitize/objSanitize.ts","../src/casing/toSnakeCase/toSnakeCase.ts"],"sourcesContent":["/**\n * Pick specific keys from an object.\n * @example\n * ```ts\n * const obj = {\n *   \"one\": true,\n *   \"two\": false,\n *   \"foo\": \"bar\"\n * };\n *\n * objPick(obj, ['two', 'foo']);\n *\n * =>\n * {\n *   \"two\": false,\n *   \"foo\": \"bar\"\n * }\n * ```\n *\n * @typedef {Object} Options\n * @property {Boolean} [upsert=false] Create new properties for missing keys.\n * @property {any} [defaultValue] Default value to use for upsert.\n *\n * @param {Object} obj Source object.\n * @param {any[]} keys Array of keys to objPick.\n * @param {Options} options Object objPick options.\n *\n * @returns {Object} Object with specified keys.\n */\nconst objPick = <Type extends Record<any, any>, Key extends keyof Type>(\n  obj: Type,\n  keys: Key[] | string[],\n  options?: {\n    upsert?: boolean;\n    defaultValue?: any;\n  },\n): Record<typeof keys[any], typeof obj[keyof typeof obj]> => {\n  const { upsert, defaultValue } = options || {};\n  const newObj: Record<any, any> = {};\n\n  keys.forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      newObj[key] = obj[key];\n    } else if (upsert) {\n      newObj[key] = defaultValue || null;\n    }\n  });\n\n  return newObj;\n};\n\nexport default objPick;\n","/**\n * Check if object has a specific key or an array of keys.\n * @example\n * ```ts\n * const obj = {\n *   \"foo\": true,\n *   \"bar\": false\n * };\n *\n * hasKey(obj, 'foo');\n * => true\n *\n * hasKey(obj, ['foo', 'bar']);\n * => true\n * ```\n * @param {Object} obj Source object.\n * @param {any | any[]} keys The key or array of keys to check.\n *\n * @returns {Boolean} Result.\n */\nconst hasKey = <Type extends Record<any, any>, Key extends keyof Type>(\n  obj: Type,\n  keys: Key | Key[],\n): boolean => {\n  let hasKeys = true;\n\n  if (Array.isArray(keys)) {\n    keys.forEach((key) => {\n      if (!hasKey(obj, key)) {\n        hasKeys = false;\n      }\n    });\n  } else {\n    if (!Object.prototype.hasOwnProperty.call(obj, keys)) {\n      hasKeys = false;\n    }\n  }\n\n  return hasKeys;\n};\n\nexport default hasKey;\n","/**\n * Sanitize an object.\n * @example\n * ```ts\n * objSanitize({\n *   \"1\": null,\n *   \"2\": \"two\",\n *   \"3\": undefined\n * });\n *\n * =>\n * {\n *   \"2\": \"two\"\n * }\n *\n * objSanitize({\n *   \"foo\": 1,\n *   \"bar\": \"one\"\n * }, {\n *   validate: (value) => typeof value !== 'string',\n * });\n *\n * =>\n * {\n *   \"foo\": 1\n * }\n * ```\n *\n * @typedef {Object} Options\n * @property {Function} [validate] Custom validator function.\n * @property {Boolean} [preserveOriginal=false] Preserve the original object.\n * @property {Boolean} [removeEmptyStrings=false] Remove empty strings.\n * @property {Boolean} [removeEmptyObjects=false] Remove empty nested objects.\n *\n * @param {Object} obj Source object.\n * @param {Options} [options] Object objSanitize options.\n *\n * @returns {Object} Sanitized object.\n */\n\nconst objSanitize = <Type extends Record<any, any>>(\n  obj: Type,\n  options?: {\n    validate?: (value: typeof obj[keyof typeof obj]) => boolean;\n    preserveOriginal?: boolean;\n    removeEmptyStrings?: boolean;\n    removeEmptyObjects?: boolean;\n  },\n): Partial<Type> => {\n  const { validate, preserveOriginal, removeEmptyStrings, removeEmptyObjects } =\n    options || {};\n  const objToModify: Type = obj;\n\n  const recurse = (object: Record<any, any>): any => {\n    for (const key in object) {\n      const isInvalid = validate ? !validate(object[key]) : false;\n\n      const isEmptyObject =\n        removeEmptyObjects &&\n        object[key] &&\n        typeof object[key] === 'object' &&\n        Object.keys(object[key]).length === 0;\n\n      const isEmptyStr =\n        removeEmptyStrings &&\n        typeof object[key] === 'string' &&\n        !object[key].trim();\n\n      if (\n        object[key] === null ||\n        object[key] === undefined ||\n        isEmptyStr ||\n        isEmptyObject ||\n        isInvalid\n      ) {\n        delete object[key];\n      } else if (typeof object[key] === 'object') {\n        recurse(object[key]);\n      }\n    }\n  };\n\n  recurse(preserveOriginal ? objToModify : obj);\n\n  return preserveOriginal ? objToModify : obj;\n};\n\nexport default objSanitize;\n","/**\n * Converts a string to snake_case.\n * @example\n * ```ts\n * toSnakeCase('camelCase');\n *\n * => camel_case\n * ```\n *\n * @typedef {Object} Options\n * @property {String} [separator=\"_\"] Separator.\n *\n * @param {String} input Source string.\n * @param {Options} options Snake case options.\n *\n * @returns {String} Snake cased string.\n */\nconst toSnakeCase = (\n  input: string,\n  options?: {\n    separator?: string;\n  },\n): string => {\n  const { separator } = options || {};\n\n  return input\n    .replace(/([a-z])([A-Z]+)/g, (_, s1: string, s2: string) => s1 + ' ' + s2)\n    .replace(\n      /([A-Z])([A-Z]+)([^a-zA-Z0-9]*)$/,\n      (_, s1: string, s2: string, s3: string) => s1 + s2.toLowerCase() + s3,\n    )\n    .replace(\n      /([A-Z]+)([A-Z][a-z])/g,\n      (_, s1: string, s2: string) => s1.toLowerCase() + ' ' + s2,\n    )\n    .replace(/\\W+/g, ' ')\n    .split(/ |\\B(?=[A-Z])/)\n    .map((word: string) => word.toLowerCase())\n    .join(separator || '_');\n};\n\nexport default toSnakeCase;\n"],"names":["hasKey","obj","keys","hasKeys","Array","isArray","forEach","key","Object","prototype","hasOwnProperty","call","options","_a","upsert","defaultValue","newObj","validate","preserveOriginal","removeEmptyStrings","removeEmptyObjects","objToModify","recurse","object","isInvalid","isEmptyObject","length","isEmptyStr","trim","undefined","input","separator","replace","_","s1","s2","s3","toLowerCase","split","map","word","join"],"mappings":";;;;;8OA6BM,ICTAA,EAAS,SACbC,EACAC,GAEA,IAAIC,GAAU,EAcd,OAZIC,MAAMC,QAAQH,GAChBA,EAAKI,SAAQ,SAACC,GACPP,EAAOC,EAAKM,KACfJ,GAAU,EAEd,IAEKK,OAAOC,UAAUC,eAAeC,KAAKV,EAAKC,KAC7CC,GAAU,GAIPA,CACT,uBDVgB,SACdF,EACAC,EACAU,GAKM,IAAAC,EAA2BD,GAAW,CAAA,EAApCE,EAAMD,EAAAC,OAAEC,EAAYF,EAAAE,aACtBC,EAA2B,CAAA,EAUjC,OARAd,EAAKI,SAAQ,SAACC,GACRC,OAAOC,UAAUC,eAAeC,KAAKV,EAAKM,GAC5CS,EAAOT,GAAON,EAAIM,GACTO,IACTE,EAAOT,GAAOQ,GAAgB,KAElC,IAEOC,CACT,gBEToB,SAClBf,EACAW,GAOM,IAAAC,EACJD,GAAW,CAAA,EADLK,EAAQJ,EAAAI,SAAEC,EAAgBL,EAAAK,iBAAEC,EAAkBN,EAAAM,mBAAEC,uBAElDC,EAAoBpB,EAEpBqB,EAAU,SAACC,GACf,IAAK,IAAMhB,KAAOgB,EAAQ,CACxB,IAAMC,IAAYP,IAAYA,EAASM,EAAOhB,IAExCkB,EACJL,GACAG,EAAOhB,IACgB,iBAAhBgB,EAAOhB,IACsB,IAApCC,OAAON,KAAKqB,EAAOhB,IAAMmB,OAErBC,EACJR,GACuB,iBAAhBI,EAAOhB,KACbgB,EAAOhB,GAAKqB,OAGG,OAAhBL,EAAOhB,SACSsB,IAAhBN,EAAOhB,IACPoB,GACAF,GACAD,SAEOD,EAAOhB,GACkB,iBAAhBgB,EAAOhB,IACvBe,EAAQC,EAAOhB,GAElB,CACH,EAIA,OAFAe,EAAQJ,EAAmBG,EAAcpB,GAElCiB,EAAmBG,EAAcpB,CAC1C,gBCpEoB,SAClB6B,EACAlB,GAIQ,IAAAmB,GAAcnB,GAAW,CAAA,aAEjC,OAAOkB,EACJE,QAAQ,oBAAoB,SAACC,EAAGC,EAAYC,GAAe,OAAAD,EAAK,IAAMC,KACtEH,QACC,mCACA,SAACC,EAAGC,EAAYC,EAAYC,GAAe,OAAAF,EAAKC,EAAGE,cAAgBD,CAAxB,IAE5CJ,QACC,yBACA,SAACC,EAAGC,EAAYC,GAAe,OAAAD,EAAGG,cAAgB,IAAMF,CAAzB,IAEhCH,QAAQ,OAAQ,KAChBM,MAAM,iBACNC,KAAI,SAACC,GAAiB,OAAAA,EAAKH,iBAC3BI,KAAKV,GAAa,IACvB"}