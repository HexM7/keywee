{"version":3,"file":"index.umd.js","sources":["../src/array/arrCross/arrCross.ts","../src/array/arrDiff/arrDiff.ts","../src/array/arrUnion/arrUnion.ts","../src/object/hasKey/hasKey.ts","../src/object/objFlush/objFlush.ts","../src/object/objKeys/objKeys.ts","../src/object/objPick/objPick.ts","../src/object/objSanitize/objSanitize.ts","../src/object/objValues/objValues.ts","../src/string/snakeCase/snakeCase.ts"],"sourcesContent":["/**\n * Returns common elements from the both the arrays.\n * @example\n * ```ts\n * arrCross([1, 2, 3, 4], [2, 3]);\n *\n * => [2, 3]\n * ```\n *\n * @param {Array} arr An array.\n * @param {Array} relArr Another array.\n *\n * @returns {Array} Intersecting elements of the arrays.\n */\nconst arrCross = (arr: any[], relArr: any[]): any[] => {\n  return arr.filter((value) => relArr.indexOf(value) !== -1);\n};\n\nexport default arrCross;\n","/**\n * Returns distinct elements from the first array that are not present in the second array.\n * @example\n * ```ts\n * arrDiff([1, 2, 3, 4], [2, 3]);\n *\n * => [1, 4]\n * ```\n *\n * @param {Array} arr An array.\n * @param {Array} relArr Another array.\n *\n * @returns {Array} Distinct elements from the first array that are not present in the second array.\n */\nconst arrDiff = (arr: any[], relArr: any[]): any[] => {\n  return arr.filter((value) => relArr.indexOf(value) === -1);\n};\n\nexport default arrDiff;\n","import { arrDiff } from '../arrDiff';\n\n/**\n * Clones distinct elements from the second array to the first array.\n * @example\n * ```ts\n * arrUnion([1, 2, 3, 4, 5], [1, 3, 5, 7]);\n *\n * => [1, 2, 3, 4, 5, 7]\n * ```\n *\n * @param {Array} arr An array.\n * @param {Array} relArr Another array.\n *\n * @returns {Array} Union of both the arrays.\n */\nconst arrUnion = (arr: any[], relArr: any[]): any[] => {\n  return [...arr, ...arrDiff(relArr, arr)];\n};\n\nexport default arrUnion;\n","/**\n * Check if object has a specific key or an array of keys.\n * @example\n * ```ts\n * const obj = {\n *   \"foo\": true,\n *   \"bar\": false\n * };\n *\n * hasKey(obj, 'foo');\n * => true\n *\n * hasKey(obj, ['foo', 'bar']);\n * => true\n * ```\n * @param {Object} obj Source object.\n * @param {any | any[]} keys The key or array of keys to check.\n *\n * @returns {Boolean} Result.\n */\nconst hasKey = <Type extends Record<any, any>, Key extends keyof Type>(\n  obj: Type,\n  keys: Key | Key[],\n): boolean => {\n  let hasKeys = true;\n\n  if (Array.isArray(keys)) {\n    let i = keys.length;\n    while (i--) {\n      if (!hasKey(obj, keys[i] as Key)) {\n        hasKeys = false;\n        break;\n      }\n    }\n  } else {\n    if (!Object.prototype.hasOwnProperty.call(obj, keys)) {\n      hasKeys = false;\n    }\n  }\n\n  return hasKeys;\n};\n\nexport default hasKey;\n","import { hasKey } from '../hasKey';\n\n/**\n * Deletes a key, an arrays of keys or all keys from an object.\n * @example\n * ```ts\n * const obj = {\n *   \"foo\": true,\n *   \"bar\": false,\n *   \"one\": 2\n * };\n *\n * objFlush(obj, 'foo');\n * =>\n * {\n *   \"bar\": false,\n *   \"one\": 2\n * }\n *\n * objFlush(obj, ['foo', 'bar']);\n * => {\n *   \"one\": 2\n * }\n *\n * objFlush(obj);\n * => {}\n * ```\n * @param {Object} obj Source object.\n * @param {any | any[]} [keys] The key or an array of keys to remove.\n *\n * @returns {Boolean} Resultant object.\n */\nconst objFlush = <Type extends Record<any, any>, Key extends keyof Type>(\n  obj: Type,\n  keys?: Key | Key[],\n): Partial<Type> => {\n  if (!keys) {\n    for (const key in obj) {\n      if (hasKey(obj, key)) {\n        delete obj[key];\n      }\n    }\n  } else if (Array.isArray(keys)) {\n    let i = keys.length;\n    while (i--) {\n      if (hasKey(obj, keys[i])) {\n        delete obj[keys[i]];\n      }\n    }\n  } else if (hasKey(obj, keys)) {\n    delete obj[keys];\n  }\n\n  return obj;\n};\n\nexport default objFlush;\n","import { hasKey } from '../hasKey';\n\n/**\n * Returns an array of keys of an object.\n * @example\n * ```ts\n * const obj = {\n *   \"foo\": true,\n *   \"bar\": false,\n * };\n *\n * objKeys(obj);\n * => ['foo', 'bar']\n * ```\n * @param {Object} obj Source object.\n *\n * @returns {Array} Keys of the object.\n */\nconst objKeys = <Type extends Record<any, any>>(\n  obj: Type,\n): Array<keyof Type> => {\n  const keys: Array<keyof Type> = [];\n\n  for (const key in obj) {\n    if (hasKey(obj, key)) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n};\n\nexport default objKeys;\n","import { hasKey } from '../hasKey';\n\n/**\n * Pick specific keys from an object.\n * @example\n * ```ts\n * const obj = {\n *   \"one\": true,\n *   \"two\": false,\n *   \"foo\": \"bar\"\n * };\n *\n * objPick(obj, ['two', 'foo']);\n *\n * =>\n * {\n *   \"two\": false,\n *   \"foo\": \"bar\"\n * }\n * ```\n *\n * @typedef {Object} Options\n * @property {Boolean} [upsert=false] Create new properties for missing keys.\n * @property {any} [defaultValue] Default value to use for upsert.\n *\n * @param {Object} obj Source object.\n * @param {any[]} keys Array of keys to objPick.\n * @param {Options} options Object objPick options.\n *\n * @returns {Object} Object with specified keys.\n */\nconst objPick = <Type extends Record<any, any>, Key extends keyof Type>(\n  obj: Type,\n  keys: Key[] | string[],\n  options?: {\n    defaultValue?: any;\n    upsert?: boolean;\n  },\n): Record<typeof keys[any], typeof obj[keyof typeof obj]> => {\n  const { defaultValue, upsert } = options || {};\n  const newObj: Record<any, any> = {};\n\n  let i = keys.length;\n  while (i--) {\n    if (hasKey(obj, keys[i])) {\n      newObj[keys[i]] = obj[keys[i]];\n    } else if (upsert) {\n      newObj[keys[i]] = defaultValue || null;\n    }\n  }\n\n  return newObj;\n};\n\nexport default objPick;\n","import { hasKey } from '../hasKey';\n\n/**\n * Sanitize an object.\n * @example\n * ```ts\n * objSanitize({\n *   \"1\": null,\n *   \"2\": \"two\",\n *   \"3\": undefined\n * });\n *\n * =>\n * {\n *   \"2\": \"two\"\n * }\n *\n * objSanitize({\n *   \"foo\": 1,\n *   \"bar\": \"one\"\n * }, {\n *   validate: (value) => typeof value !== 'string',\n * });\n *\n * =>\n * {\n *   \"foo\": 1\n * }\n * ```\n *\n * @typedef {Object} Options\n * @property {Function} [validate] Custom validator function.\n * @property {Boolean} [preserveOriginal=false] Preserve the original object.\n * @property {Boolean} [removeEmptyStrings=false] Remove empty strings.\n * @property {Boolean} [removeEmptyObjects=false] Remove empty nested objects.\n *\n * @param {Object} obj Source object.\n * @param {Options} [options] Object objSanitize options.\n *\n * @returns {Object} Sanitized object.\n */\nconst objSanitize = <Type extends Record<any, any>>(\n  obj: Type,\n  options?: {\n    preserveOriginal?: boolean;\n    removeEmptyObjects?: boolean;\n    removeEmptyStrings?: boolean;\n    validate?: (value: typeof obj[keyof typeof obj]) => boolean;\n  },\n): Partial<Type> => {\n  const { preserveOriginal, removeEmptyObjects, removeEmptyStrings, validate } =\n    options || {};\n  const objToModify: Type = obj;\n\n  const recurse = (object: Record<any, any>): any => {\n    for (const key in object) {\n      if (!hasKey(object, key)) continue;\n\n      const isInvalid = validate ? !validate(object[key]) : false;\n\n      const isEmptyObject =\n        removeEmptyObjects &&\n        object[key] &&\n        typeof object[key] === 'object' &&\n        Object.keys(object[key]).length === 0;\n\n      const isEmptyStr =\n        removeEmptyStrings &&\n        typeof object[key] === 'string' &&\n        !object[key].trim();\n\n      if (\n        object[key] === null ||\n        object[key] === undefined ||\n        isEmptyStr ||\n        isEmptyObject ||\n        isInvalid\n      ) {\n        delete object[key];\n      } else if (typeof object[key] === 'object') {\n        recurse(object[key]);\n      }\n    }\n  };\n\n  recurse(preserveOriginal ? objToModify : obj);\n\n  return preserveOriginal ? objToModify : obj;\n};\n\nexport default objSanitize;\n","import { hasKey } from '../hasKey';\n\n/**\n * Returns an array of values of an object.\n * @example\n * ```ts\n * const obj = {\n *   \"foo\": true,\n *   \"bar\": false,\n * };\n *\n * objValues(obj);\n * => [true, false]\n * ```\n * @param {Object} obj Source object.\n *\n * @returns {Array} Values of the object.\n */\nconst objValues = <\n  Type extends Record<any, any>,\n  Key extends keyof Type,\n  Value extends Type[Key],\n>(\n  obj: Type,\n): Value[] => {\n  const values: Value[] = [];\n\n  for (const key in obj) {\n    if (hasKey(obj, key)) {\n      values.push(obj[key]);\n    }\n  }\n\n  return values;\n};\n\nexport default objValues;\n","/**\n * Converts a string to snake_case.\n * @example\n * ```ts\n * snakeCase('camelCase');\n *\n * => camel_case\n * ```\n *\n * @typedef {Object} Options\n * @property {String} [separator=\"_\"] Separator.\n *\n * @param {String} input Source string.\n * @param {Options} options Snake case options.\n *\n * @returns {String} Snake cased string.\n */\nconst snakeCase = (\n  input: string,\n  options?: {\n    separator?: string;\n  },\n): string => {\n  const { separator } = options || {};\n  const match = input.match(\n    /[A-Z]{2,}(?=[A-Z][a-z]+\\d*|\\b)|[A-Z]?[a-z]+\\d*|[A-Z]|\\d+/g,\n  );\n\n  return match\n    ? match.map((chunk: string) => chunk.toLowerCase()).join(separator || '_')\n    : input;\n};\n\nexport default snakeCase;\n"],"names":[],"mappings":";;;;;;;;;;;;EAAA;;;;;;;;;;;;;EAaG;AACH,MAAM,QAAQ,GAAG,UAAC,GAAU,EAAE,MAAa,EAAA;MACzC,OAAO,GAAG,CAAC,MAAM,CAAC,UAAC,KAAK,EAAA,EAAK,OAAA,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAA5B,EAA4B,CAAC,CAAC;EAC7D;;EChBA;;;;;;;;;;;;;EAaG;AACH,MAAM,OAAO,GAAG,UAAC,GAAU,EAAE,MAAa,EAAA;MACxC,OAAO,GAAG,CAAC,MAAM,CAAC,UAAC,KAAK,EAAA,EAAK,OAAA,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAA5B,EAA4B,CAAC,CAAC;EAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;ECdA;;;;;;;;;;;;;EAaG;AACH,MAAM,QAAQ,GAAG,UAAC,GAAU,EAAE,MAAa,EAAA;MACzC,OAAW,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,GAAG,SAAK,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,IAAA,CAAA,CAAA;EAC3C;;EClBA;;;;;;;;;;;;;;;;;;;EAmBG;AACH,MAAM,MAAM,GAAG,UACb,GAAS,EACT,IAAiB,EAAA;MAEjB,IAAI,OAAO,GAAG,IAAI,CAAC;EAEnB,IAAA,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;EACvB,QAAA,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;UACpB,OAAO,CAAC,EAAE,EAAE;cACV,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAQ,CAAC,EAAE;kBAChC,OAAO,GAAG,KAAK,CAAC;kBAChB,MAAM;EACP,aAAA;EACF,SAAA;EACF,KAAA;EAAM,SAAA;EACL,QAAA,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE;cACpD,OAAO,GAAG,KAAK,CAAC;EACjB,SAAA;EACF,KAAA;EAED,IAAA,OAAO,OAAO,CAAC;EACjB;;ECvCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA6BG;AACH,MAAM,QAAQ,GAAG,UACf,GAAS,EACT,IAAkB,EAAA;MAElB,IAAI,CAAC,IAAI,EAAE;EACT,QAAA,KAAK,IAAM,GAAG,IAAI,GAAG,EAAE;EACrB,YAAA,IAAI,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE;EACpB,gBAAA,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;EACjB,aAAA;EACF,SAAA;EACF,KAAA;EAAM,SAAA,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;EAC9B,QAAA,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;UACpB,OAAO,CAAC,EAAE,EAAE;cACV,IAAI,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;EACxB,gBAAA,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;EACrB,aAAA;EACF,SAAA;EACF,KAAA;EAAM,SAAA,IAAI,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE;EAC5B,QAAA,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;EAClB,KAAA;EAED,IAAA,OAAO,GAAG,CAAC;EACb;;ECpDA;;;;;;;;;;;;;;;EAeG;AACG,MAAA,OAAO,GAAG,UACd,GAAS,EAAA;MAET,IAAM,IAAI,GAAsB,EAAE,CAAC;EAEnC,IAAA,KAAK,IAAM,GAAG,IAAI,GAAG,EAAE;EACrB,QAAA,IAAI,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE;EACpB,YAAA,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;EAChB,SAAA;EACF,KAAA;EAED,IAAA,OAAO,IAAI,CAAC;EACd;;EC5BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4BG;AACH,MAAM,OAAO,GAAG,UACd,GAAS,EACT,IAAsB,EACtB,OAGC,EAAA;MAEK,IAAA,EAAA,GAA2B,OAAO,IAAI,EAAE,EAAtC,YAAY,GAAA,EAAA,CAAA,YAAA,EAAE,MAAM,GAAA,EAAA,CAAA,MAAkB,CAAC;MAC/C,IAAM,MAAM,GAAqB,EAAE,CAAC;EAEpC,IAAA,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;MACpB,OAAO,CAAC,EAAE,EAAE;UACV,IAAI,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;EACxB,YAAA,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;EAChC,SAAA;EAAM,aAAA,IAAI,MAAM,EAAE;cACjB,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,YAAY,IAAI,IAAI,CAAC;EACxC,SAAA;EACF,KAAA;EAED,IAAA,OAAO,MAAM,CAAC;EAChB;;EClDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsCG;AACH,MAAM,WAAW,GAAG,UAClB,GAAS,EACT,OAKC,EAAA;EAEK,IAAA,IAAA,KACJ,OAAO,IAAI,EAAE,EADP,gBAAgB,GAAA,EAAA,CAAA,gBAAA,EAAE,kBAAkB,GAAA,EAAA,CAAA,kBAAA,EAAE,kBAAkB,GAAA,EAAA,CAAA,kBAAA,EAAE,QAAQ,cAC3D,CAAC;MAChB,IAAM,WAAW,GAAS,GAAG,CAAC;MAE9B,IAAM,OAAO,GAAG,UAAC,MAAwB,EAAA;EACvC,QAAA,KAAK,IAAM,GAAG,IAAI,MAAM,EAAE;EACxB,YAAA,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC;kBAAE,SAAS;EAEnC,YAAA,IAAM,SAAS,GAAG,QAAQ,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC;cAE5D,IAAM,aAAa,GACjB,kBAAkB;kBAClB,MAAM,CAAC,GAAG,CAAC;EACX,gBAAA,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ;EAC/B,gBAAA,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC;cAExC,IAAM,UAAU,GACd,kBAAkB;EAClB,gBAAA,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ;EAC/B,gBAAA,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;EAEtB,YAAA,IACE,MAAM,CAAC,GAAG,CAAC,KAAK,IAAI;EACpB,gBAAA,MAAM,CAAC,GAAG,CAAC,KAAK,SAAS;kBACzB,UAAU;kBACV,aAAa;EACb,gBAAA,SAAS,EACT;EACA,gBAAA,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;EACpB,aAAA;EAAM,iBAAA,IAAI,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ,EAAE;EAC1C,gBAAA,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;EACtB,aAAA;EACF,SAAA;EACH,KAAC,CAAC;MAEF,OAAO,CAAC,gBAAgB,GAAG,WAAW,GAAG,GAAG,CAAC,CAAC;MAE9C,OAAO,gBAAgB,GAAG,WAAW,GAAG,GAAG,CAAC;EAC9C;;ECtFA;;;;;;;;;;;;;;;EAeG;AACG,MAAA,SAAS,GAAG,UAKhB,GAAS,EAAA;MAET,IAAM,MAAM,GAAY,EAAE,CAAC;EAE3B,IAAA,KAAK,IAAM,GAAG,IAAI,GAAG,EAAE;EACrB,QAAA,IAAI,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE;cACpB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;EACvB,SAAA;EACF,KAAA;EAED,IAAA,OAAO,MAAM,CAAC;EAChB;;EClCA;;;;;;;;;;;;;;;;EAgBG;AACH,MAAM,SAAS,GAAG,UAChB,KAAa,EACb,OAEC,EAAA;MAEO,IAAA,SAAS,GAAK,CAAA,OAAO,IAAI,EAAE,WAAlB,CAAmB;MACpC,IAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CACvB,2DAA2D,CAC5D,CAAC;EAEF,IAAA,OAAO,KAAK;YACR,KAAK,CAAC,GAAG,CAAC,UAAC,KAAa,EAAK,EAAA,OAAA,KAAK,CAAC,WAAW,EAAE,CAAA,EAAA,CAAC,CAAC,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;YACxE,KAAK,CAAC;EACZ;;;;;;;;;;;;;;;;;;;"}